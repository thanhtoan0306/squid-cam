<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arrow Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  </head>
  <body>
    <div id="game-container"></div>
    <script>
      class ArrowGame extends Phaser.Scene {
        constructor() {
          super({ key: 'ArrowGame' });
          this.arrows = [];
          this.enemies = [];
          this.player = null;
          this.gravity = 500; // Gravity constant for calculations
          this.lastShotTime = 0;
          // this.shotCooldown = 800; // This will now be dynamic
        }

        preload() {
          // No images needed - using shapes
        }

        create() {
          // Create player at left edge, centered vertically
          this.player = this.add.rectangle(
            50,
            this.sys.game.config.height / 2,
            40,
            60,
            0x00ff00
          );

          // Create enemies group
          this.enemiesGroup = this.add.group();

          // Create arrows group
          this.arrowsGroup = this.add.group();

          // Spawn an enemy on mouse click
          this.input.on(
            'pointerdown',
            (pointer) => {
              this.spawnEnemy(pointer.x, pointer.y);
            },
            this
          );

          // Physics for collisions
          this.physics.world.enable([this.player]);
          this.player.body.setCollideWorldBounds(true);
        }

        update() {
          const time = this.time.now;
          const numEnemies = this.enemiesGroup.getLength();

          // --- Dynamic Cooldown Calculation for a continuous stream ---
          const baseCooldown = 250; // Base time between single shots
          const reductionPerEnemy = 20; // Reduce cooldown for each additional enemy
          const minCooldown = 50; // The absolute fastest firing rate

          let dynamicCooldown =
            baseCooldown - (numEnemies - 1) * reductionPerEnemy;
          dynamicCooldown = Math.max(dynamicCooldown, minCooldown); // Ensure cooldown doesn't go below minimum

          // Continuously shoot if enemies exist and cooldown is over
          if (numEnemies > 0 && time > this.lastShotTime + dynamicCooldown) {
            this.shootArrow();
            this.lastShotTime = time;
          }

          // Update arrows
          this.arrowsGroup.children.entries.forEach((arrow) => {
            this.updateArrow(arrow);
          });

          // Update enemies
          this.enemiesGroup.children.entries.forEach((enemy) => {
            enemy.x -= 0.8; // Slowed down enemy speed
            if (enemy.x < 0) {
              enemy.destroy(); // Remove if it goes off-screen
            }
          });

          // Check collisions
          this.checkCollisions();
        }

        findNearestEnemy() {
          let nearestEnemy = null;
          let minDistance = Infinity;

          this.enemiesGroup.children.entries.forEach((enemy) => {
            // We only care about horizontal distance since they are in the same lane
            const distance = enemy.x - this.player.x;
            if (distance > 0 && distance < minDistance) {
              minDistance = distance;
              nearestEnemy = enemy;
            }
          });

          return nearestEnemy;
        }

        shootArrow() {
          const target = this.findNearestEnemy();
          if (!target) {
            return; // Don't shoot if there are no enemies
          }

          const startX = this.player.x + 20;
          const startY = this.player.y;

          // --- Base trajectory calculation for the middle arrow ---
          const dx = target.x - startX;
          const dy = target.y - startY;
          const timeToTarget = 1.1;
          const base_vx = dx / timeToTarget;
          const base_vy = dy / timeToTarget - 0.5 * this.gravity * timeToTarget;

          // Convert velocity to angle and power for adjustments
          const baseAngle = Math.atan2(base_vy, base_vx);
          const power = Math.sqrt(base_vx * base_vx + base_vy * base_vy);

          // --- Clamp the angle between 30 and 60 degrees upward ---
          const minAngle = -Phaser.Math.DegToRad(60); // -60 degrees
          const maxAngle = -Phaser.Math.DegToRad(30); // -30 degrees
          const clampedAngle = Phaser.Math.Clamp(baseAngle, minAngle, maxAngle);

          // --- Fire 5 arrows with spacing ---
          const numArrows = 5;
          const angleSpacing = Phaser.Math.DegToRad(5); // 5 degrees in radians

          for (let i = 0; i < numArrows; i++) {
            // Calculate the angle for the current arrow in the spread
            const angleOffset = (i - Math.floor(numArrows / 2)) * angleSpacing;
            const currentAngle = clampedAngle + angleOffset;

            // Calculate new velocity components based on the adjusted angle
            const vx = Math.cos(currentAngle) * power;
            const vy = Math.sin(currentAngle) * power;

            // Create arrow
            const arrow = this.add.rectangle(startX, startY, 4, 20, 0xffff00);
            this.physics.world.enable(arrow);

            // Set arrow properties based on calculated trajectory
            arrow.velocityX = vx;
            arrow.velocityY = vy;
            arrow.gravity = this.gravity;

            this.arrowsGroup.add(arrow);
          }
        }

        updateArrow(arrow) {
          // Apply gravity and movement
          arrow.velocityY += arrow.gravity * 0.016; // Gravity effect
          arrow.y += arrow.velocityY * 0.016;
          arrow.x += arrow.velocityX * 0.016; // Horizontal movement

          // Update arrow rotation to match trajectory
          arrow.rotation = Math.atan2(arrow.velocityY, arrow.velocityX);

          // Remove arrow if it goes off screen
          if (arrow.y > 600 || arrow.x > 800 || arrow.x < 0) {
            arrow.destroy();
          }
        }

        spawnEnemy(x, y) {
          // Prevent spawning on top of the player
          if (x < this.player.x + 50) {
            x = this.player.x + 50;
          }
          const enemy = this.add.rectangle(x, y, 30, 30, 0xff0000); // Start as red
          this.physics.world.enable(enemy);

          // Give the enemy 3 HP
          enemy.hp = 3;

          this.enemiesGroup.add(enemy);
        }

        checkCollisions() {
          this.arrowsGroup.children.entries.forEach((arrow) => {
            this.enemiesGroup.children.entries.forEach((enemy) => {
              if (
                enemy.active &&
                arrow.active &&
                Phaser.Geom.Rectangle.Overlaps(
                  arrow.getBounds(),
                  enemy.getBounds()
                )
              ) {
                // Destroy the arrow on impact
                arrow.destroy();

                // Reduce enemy HP
                enemy.hp -= 1;

                // Check if enemy is defeated
                if (enemy.hp <= 0) {
                  enemy.destroy();
                  console.log('Enemy defeated!');
                } else {
                  // Update color based on remaining HP
                  if (enemy.hp === 2) {
                    enemy.setFillStyle(0xffa500); // Orange
                  } else if (enemy.hp === 1) {
                    enemy.setFillStyle(0xffff00); // Yellow
                  }
                }
              }
            });
          });

          // Check if enemy reaches player
          this.enemiesGroup.children.entries.forEach((enemy) => {
            if (
              enemy.active &&
              Phaser.Geom.Rectangle.Overlaps(
                this.player.getBounds(),
                enemy.getBounds()
              )
            ) {
              enemy.destroy();
              console.log('Player hit! Game Over!');
              // Add game over logic here
            }
          });
        }
      }

      // Game configuration
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: 'arcade',
          arcade: {
            gravity: { y: 0 },
            debug: false,
          },
        },
        scene: ArrowGame,
      };

      // Start the game
      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
