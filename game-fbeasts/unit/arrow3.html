<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arrow Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  </head>
  <body>
    <div id="game-container"></div>
    <script>
      class ArrowGame extends Phaser.Scene {
        constructor() {
          super({ key: 'ArrowGame' });
          this.arrows = [];
          this.enemies = [];
          this.player = null;
          this.gravity = 500; // Gravity constant for calculations

          // Player-controlled shooting parameters
          this.shootAngle = -45; // Negative is upward, in degrees
          this.shootPower = 450; // Increased starting shooting power/velocity
        }

        preload() {
          // No images needed - using shapes
        }

        create() {
          // Create player at left edge (green rectangle)
          this.player = this.add.rectangle(50, 300, 40, 60, 0x00ff00);

          // Create enemies group
          this.enemiesGroup = this.add.group();

          // Create arrows group
          this.arrowsGroup = this.add.group();

          // Create aim indicator (shows direction)
          this.aimLine = this.add.line(0, 0, 0, 0, 100, 0, 0xffff00);
          this.aimLine.setOrigin(0, 0);
          this.updateAimLine();

          // Spawn 3 static enemies one time
          for (let i = 0; i < 3; i++) {
            const x = 500 + i * 100; // x position with 100px spacing
            const y = 300; // fixed y position
            const enemy = this.add.rectangle(x, y, 30, 30, 0xff0000);
            this.physics.world.enable(enemy);
            enemy.body.setImmovable(true); // Make them static and unmovable
            this.enemiesGroup.add(enemy);
          }

          // Input controls
          this.cursors = this.input.keyboard.createCursorKeys();
          this.wKey = this.input.keyboard.addKey(
            Phaser.Input.Keyboard.KeyCodes.W
          );
          this.sKey = this.input.keyboard.addKey(
            Phaser.Input.Keyboard.KeyCodes.S
          );
          this.aKey = this.input.keyboard.addKey(
            Phaser.Input.Keyboard.KeyCodes.A
          );
          this.dKey = this.input.keyboard.addKey(
            Phaser.Input.Keyboard.KeyCodes.D
          );

          // Fire arrow on mouse click
          this.input.on('pointerdown', this.shootArrow, this);

          // Physics for collisions
          this.physics.world.enable([this.player]);
          this.player.body.setCollideWorldBounds(true);

          // Debug text to show targeting info
          this.debugText = this.add.text(10, 10, '', {
            fontSize: '16px',
            fill: '#fff',
          });
          this.updateDebugText();
        }

        update() {
          // Player movement (only up/down since at left edge)
          if (this.cursors.up.isDown && this.player.y > 30) {
            this.player.y -= 5;
          }
          if (this.cursors.down.isDown && this.player.y < 570) {
            this.player.y += 5;
          }

          // Adjust aim angle (W/S keys)
          if (this.wKey.isDown) {
            this.shootAngle -= 1; // Increase upward angle
            if (this.shootAngle < -80) this.shootAngle = -80; // Limit angle
            this.updateAimLine();
            this.updateDebugText();
          }
          if (this.sKey.isDown) {
            this.shootAngle += 1; // Decrease upward angle
            if (this.shootAngle > -10) this.shootAngle = -10; // Limit angle
            this.updateAimLine();
            this.updateDebugText();
          }

          // Adjust power (A/D keys)
          if (this.aKey.isDown) {
            this.shootPower -= 5; // Decrease power
            if (this.shootPower < 150) this.shootPower = 150; // Minimum power
            this.updateAimLine();
            this.updateDebugText();
          }
          if (this.dKey.isDown) {
            this.shootPower += 5; // Increase power
            if (this.shootPower > 800) this.shootPower = 800; // Increased maximum power
            this.updateAimLine();
            this.updateDebugText();
          }

          // Update arrows
          this.arrowsGroup.children.entries.forEach((arrow) => {
            this.updateArrow(arrow);
          });

          // Update aim line position to follow player
          this.aimLine.setPosition(this.player.x + 20, this.player.y);

          // Check collisions
          this.checkCollisions();
        }

        updateAimLine() {
          // Convert angle from degrees to radians
          const angleRad = Phaser.Math.DegToRad(this.shootAngle);

          // Calculate end point based on angle and power
          const lineLength = this.shootPower / 5; // Scale down for visualization
          const endX = Math.cos(angleRad) * lineLength;
          const endY = Math.sin(angleRad) * lineLength;

          // Update the line
          this.aimLine.setTo(0, 0, endX, endY);
        }

        updateDebugText() {
          this.debugText.setText(
            `Angle: ${this.shootAngle.toFixed(0)}Â°\nPower: ${
              this.shootPower
            }\nControls: W/S adjust angle, A/D adjust power, Click to fire`
          );
        }

        shootArrow() {
          const numArrows = 5;
          const angleSpacing = 5; // degrees
          const startAngle =
            this.shootAngle - (angleSpacing * (numArrows - 1)) / 2;

          for (let i = 0; i < numArrows; i++) {
            const currentAngle = startAngle + i * angleSpacing;

            // Convert angle from degrees to radians
            const angleRad = Phaser.Math.DegToRad(currentAngle);

            // Calculate velocity components based on angle and power
            const vx = Math.cos(angleRad) * this.shootPower;
            const vy = Math.sin(angleRad) * this.shootPower;

            // Create arrow
            const arrow = this.add.rectangle(
              this.player.x + 20,
              this.player.y,
              4,
              20,
              0xffff00
            );
            this.physics.world.enable(arrow);

            // Set arrow properties based on calculated trajectory
            arrow.velocityX = vx;
            arrow.velocityY = vy;
            arrow.gravity = this.gravity;
            arrow.isArrow = true;

            // Set initial rotation based on velocity
            arrow.rotation = angleRad;

            this.arrowsGroup.add(arrow);
          }
        }

        updateArrow(arrow) {
          // Apply gravity and movement
          arrow.velocityY += arrow.gravity * 0.016; // Gravity effect
          arrow.y += arrow.velocityY * 0.016;
          arrow.x += arrow.velocityX * 0.016; // Horizontal movement

          // Update arrow rotation to match trajectory
          arrow.rotation = Math.atan2(arrow.velocityY, arrow.velocityX);

          // Remove arrow if it goes off screen
          if (arrow.y > 600 || arrow.y < 0 || arrow.x > 800) {
            arrow.destroy();
          }
        }

        checkCollisions() {
          this.arrowsGroup.children.entries.forEach((arrow) => {
            this.enemiesGroup.children.entries.forEach((enemy) => {
              if (
                enemy.active &&
                arrow.active &&
                Phaser.Geom.Rectangle.Overlaps(
                  arrow.getBounds(),
                  enemy.getBounds()
                )
              ) {
                // Hit enemy
                arrow.destroy();
                enemy.destroy();

                // Add score or effects here
                console.log('Enemy hit!');
              }
            });
          });
        }
      }

      // Game configuration
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: 'arcade',
          arcade: {
            gravity: { y: 0 },
            debug: false,
          },
        },
        scene: ArrowGame,
      };

      // Start the game
      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
