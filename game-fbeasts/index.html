<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bullet Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
      .test {
        color: #79a7e4;
      }
    </style>
  </head>
  <body>
    <div id="game-container"></div>
    <script>
      console.log('Bullet Game Loaded');
      const emitter = new Phaser.Events.EventEmitter();

      class BulletGame extends Phaser.Scene {
        constructor() {
          super({ key: 'BulletGame' });
          this.bullets = [];
          this.enemies = [];
          this.player = null;
          this.gravity = 500; // Gravity constant for calculations
          this.lastShotTime = 0;
          this.fireLocked = false;

          // === Adjustable variables ===
          this.enemyHP = 10; // Default HP for each enemy
          this.baseCooldown = 1000; // Base attack cooldown in ms
          this.reductionPerEnemy = 20; // Cooldown reduction per enemy
          this.minCooldown = 50; // Minimum cooldown
        }

        preload() {
          this.load.audio(
            'explosionSound',
            'assets/sounds/energyshot-impact4.wav'
          );
          this.load.image('bg', 'assets/bg1.png');

          // Load zombie walk frames as before
          for (let i = 0; i <= 9; i++) {
            const frameNum = i.toString().padStart(3, '0');
            this.load.image(
              `zombie_walk_${frameNum}`,
              `assets/ZombieOGA/Walk/__Zombie01_Walk_${frameNum}.png`
            );
          }
          // Load wizard attack spritesheet
          for (let i = 0; i <= 7; i++) {
            const frameNum = i.toString().padStart(2, '0');
            this.load.image(
              `guangzu_0000${frameNum}`,
              `assets/Guangzu/0300${frameNum}.png`
            );
          }

          // Load GZ Idle frames
          for (let i = 0; i <= 5; i++) {
            const frameNum = i.toString().padStart(2, '0');
            this.load.image(
              `gz_idle_${frameNum}`,
              `assets/GZ_Idle/0300${frameNum}.png`
            );
          }

          this.load.image('bullet_particle', 'assets/blue.png'); // Load the glow image

          // Load explosion animation frames
          for (let i = 1; i <= 10; i++) {
            this.load.image(
              `explosion_${i}`,
              `assets/Explosion_lightning/Explosion_${i}.png`
            );
          }

          // Load the avatar image
          this.load.image(
            'avatarGojo',
            'assets/avataricon.jpg'
            // 'assets/blue.png'
            // 'https://plus.unsplash.com/premium_photo-1745950166788-96be20d65198?q=80&w=1333&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'
          );

          // Load BossEnemy frames
          for (let i = 0; i <= 7; i++) {
            const frameNum = i.toString().padStart(6, '0');
            console.log('asset: ', `assets/boss2/${frameNum}.png`);

            this.load.image(
              `boss_walk_${frameNum}`,
              `assets/boss2/${frameNum}.png`
            );
          }
        }

        create() {
          this.sys.game.events.off('blur', this.scene.pause, this);
          this.sys.game.events.off('pause', this.scene.pause, this);
          // Define the Y positions for the three lanes
          this.add
            .image(
              this.sys.game.config.width / 2,
              this.sys.game.config.height / 2 - 100,
              'bg'
            )
            .setDisplaySize(
              this.sys.game.config.width,
              this.sys.game.config.height
            );
          this.laneYPositions = [
            this.sys.game.config.height * 0.35, // Top lane
            this.sys.game.config.height * 0.5, // Middle lane
            this.sys.game.config.height * 0.65, // Bottom lane
          ];

          // Create wizard attack animation with faster frameRate

          this.anims.create({
            key: 'guangzu_anim',
            frames: [
              { key: 'guangzu_000000' },
              { key: 'guangzu_000001' },
              { key: 'guangzu_000002' },
              { key: 'guangzu_000003' },
              { key: 'guangzu_000004' },
              { key: 'guangzu_000005' },
              { key: 'guangzu_000006' },
              { key: 'guangzu_000007' },
            ],
            frameRate: 22,
            repeat: 0,
          });

          this.anims.create({
            key: 'gz_idle',
            frames: [
              { key: 'gz_idle_00' },
              { key: 'gz_idle_01' },
              { key: 'gz_idle_02' },
              { key: 'gz_idle_03' },
              { key: 'gz_idle_04' },
              { key: 'gz_idle_05' },
            ],
            frameRate: 8,
            repeat: -1,
          });

          // --- Replace rectangle player with wizard sprite ---
          const desiredHeight = 60 * 10; // 5x bigger than before
          const playerX = 150;
          const playerLaneY = this.laneYPositions[1];

          this.player = this.add.sprite(playerX, 0, 'guangzu_000000', 0);

          this.physics.world.enable(this.player);

          // Crop 30% from the left
          const cropX = this.player.width * 0.3;
          const cropWidth = this.player.width * 0.7;
          this.player.setCrop(cropX, 0, cropWidth, this.player.height);

          const scale = desiredHeight / this.player.height;
          this.player.setScale(scale);

          // Now, player.x = 0 means the left edge is at the scene's left edge
          this.player.x = playerX; // Or set to 0 for very left

          this.player.y = playerLaneY;

          this.player.body.setCollideWorldBounds(false);

          // Create enemies group
          this.enemiesGroup = this.add.group();

          // Create bullets group
          this.bulletsGroup = this.add.group();

          // Create walk animation from loaded frames
          this.anims.create({
            key: 'zombie_walk',
            frames: Array.from({ length: 10 }, (_, i) => ({
              key: `zombie_walk_${i.toString().padStart(3, '0')}`,
            })),
            frameRate: 10,
            repeat: -1,
          });

          this.anims.create({
            key: 'boss_walk',
            frames: Array.from({ length: 8 }, (_, i) => ({
              key: `boss_walk_${i.toString().padStart(6, '0')}`,
            })),
            frameRate: 8,
            repeat: -1,
          });

          emitter.on('spawn-enemy', (username, avatar, userId, likeCount) => {
            for (let i = 0; i < likeCount; i++) {
              const laneY =
                this.laneYPositions[
                  Math.floor(Math.random() * this.laneYPositions.length)
                ];
              this.spawnEnemy(950, laneY, username, avatar, userId);
            }
          });
          // Spawn an enemy on mouse click in the nearest lane
          this.input.on(
            'pointerdown',
            (pointer) => {
              // Find the closest lane to the click
              let closestLaneY = this.laneYPositions[0];
              let minDistance = Math.abs(pointer.y - closestLaneY);

              for (let i = 1; i < this.laneYPositions.length; i++) {
                const distance = Math.abs(pointer.y - this.laneYPositions[i]);
                if (distance < minDistance) {
                  minDistance = distance;
                  closestLaneY = this.laneYPositions[i];
                }
              }

              this.spawnEnemy(pointer.x, closestLaneY, '', '', '', true);
            },
            this
          );

          // Create particle emitter for bullet visuals
          this.bulletEmitter = this.add.particles(0, 0, 'bullet_particle', {
            speed: 0, // We'll move particles manually to match bullets
            scale: { start: 0.6, end: 0.6 },
            lifespan: 20,
            blendMode: 'ADD',
            quantity: 1,
            emitting: false,
          });

          // Keep your existing bullet group for logic
          this.bulletsGroup = this.physics.add.group();

          // Create explosion animation
          this.anims.create({
            key: 'explosion',
            frames: Array.from({ length: 10 }, (_, i) => ({
              key: `explosion_${i + 1}`,
            })),
            frameRate: 48,
            hideOnComplete: true,
          });

          // Add key input for toggling fire lock
          this.input.keyboard.on('keydown-A', () => {
            this.fireLocked = !this.fireLocked;
            console.log('Player fire locked:', this.fireLocked);
          });

          // Add a wall sprite or rectangle in front of the player
          const wallX = this.player.x + 150; // Adjust distance as needed
          const wallY = this.player.y;
          const wallHeight = 380;
          const wallWidth = 20;

          // Use a graphics rectangle for the wall
          this.wall = this.add.rectangle(
            wallX,
            wallY,
            wallWidth,
            wallHeight,
            0x888888
          );
          this.physics.add.existing(this.wall, true); // true = static body

          this.player.anims.play('gz_idle'); // Play idle by default

          // --- Yu-Gi-Oh! style card ---
          this.cardContainer = this.add.container(
            this.sys.game.config.width / 2,
            this.sys.game.config.height / 2 - 50
          );

          // Viền vàng ngoài
          const border = this.add.rectangle(0, 0, 420, 620, 0xFFD700);
          this.cardContainer.add(border);

          // Nền đen bên trong
          const inner = this.add.rectangle(0, 0, 400, 600, 0x222222);
          this.cardContainer.add(inner);

          // Hàm cắt text và thêm ... nếu quá dài
          function truncateTextToWidth(scene, text, maxWidth, style) {
            let tempText = scene.add.text(0, 0, text, style).setVisible(false);
            let truncated = text;
            while (tempText.width > maxWidth && truncated.length > 0) {
              truncated = truncated.slice(0, -1);
              tempText.setText(truncated + '...');
            }
            tempText.destroy();
            return (truncated.length < text.length) ? truncated + '...' : text;
          }

          const nameRaw = '🦁 Just A Clone 🇺🇸🤖';
          const nameStyle = {
            fontFamily: 'Arial',
            fontSize: '28px',
            color: '#ffe066',
            fontStyle: 'bold',
            align: 'center',
            stroke: '#000',
            strokeThickness: 4,
          };
          const paddingLeft = 20;
          const nameMaxWidth = 370 - paddingLeft; // Không cần trừ icon nữa
          const nameTextStr = truncateTextToWidth(this, nameRaw, nameMaxWidth, nameStyle);
          // nameText căn giữa lại
          const nameText = this.add.text(0, -270, nameTextStr, nameStyle);
          nameText.setOrigin(0.5, 0.5);
          this.cardContainer.add(nameText);

          // Khung ảnh minh họa
          const artBorder = this.add.rectangle(0, -40, 360, 360, 0xFFD700);
          this.cardContainer.add(artBorder);
          const artBg = this.add.rectangle(0, -40, 340, 340, 0x000000);
          this.cardContainer.add(artBg);
          // Ảnh minh họa (avatarGojo)
          const artImg = this.add.image(0, -40, 'avatarGojo').setDisplaySize(340, 340);
          this.cardContainer.add(artImg);

          // Khung mô tả
          const descBg = this.add.rectangle(0, 180, 360, 120, 0xffffff);
          this.cardContainer.add(descBg);
          const descText = this.add.text(0, 150, '💙my🏠@Ryy 🦁🇻🇳🧡~acc phu👉🏻@ndt2followbyryy ~thanks for like & follow 🙆‍♂️', {
            fontFamily: 'serif',
            fontSize: '22px',
            color: '#000',
            wordWrap: { width: 340 }
          });
          descText.setOrigin(0.5, 0);
          this.cardContainer.add(descText);

          this.cardContainer.setVisible(false);
          this.cardContainer.setDepth(1000);

          // Hiển thị card ngay khi load scene, không cần tween hiệu ứng
          this.isCardFreeze = true;
          this.cardContainer.setPosition(
            this.sys.game.config.width / 2,
            this.sys.game.config.height / 2 - 50
          );
          this.cardContainer.setVisible(true);
          this.cardContainer.setAlpha(1);
          this.cardContainer.setScale(1, 1);
          // Không chạy tween, card giữ nguyên trên màn hình

          /*
          // --- Tween hiệu ứng xuất hiện/ẩn card (bỏ comment để dùng lại) ---
          this.cardContainer.setAlpha(0);
          this.cardContainer.setScale(0.5, 0.5);
          this.tweens.add({
            targets: this.cardContainer,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
            ease: 'Back.Out',
            duration: 400,
            onComplete: () => {
              this.time.delayedCall(2200, () => {
                this.tweens.add({
                  targets: this.cardContainer,
                  scaleX: -1,
                  ease: 'Cubic.InOut',
                  duration: 400,
                  yoyo: true,
                  onYoyo: () => {
                    this.tweens.add({
                      targets: this.cardContainer,
                      alpha: 0,
                      scaleX: 0.5,
                      scaleY: 0.5,
                      ease: 'Back.In',
                      duration: 400,
                      onComplete: () => {
                        this.cardContainer.setVisible(false);
                        this.cardContainer.setScale(1, 1);
                        this.cardContainer.scaleX = 1;
                        this.isCardFreeze = false;
                      },
                    });
                  },
                });
              });
            },
          });
          */
        }

        update() {
          const time = this.time.now;
          const numEnemies = this.enemiesGroup.getLength();

          // --- Dynamic Cooldown Calculation for a continuous stream ---
          const baseCooldown = this.baseCooldown; // Base time between single shots
          const reductionPerEnemy = 20; // Reduce cooldown for each additional enemy
          const minCooldown = 50; // The absolute fastest firing rate

          let dynamicCooldown =
            baseCooldown - (numEnemies - 1) * reductionPerEnemy;
          dynamicCooldown = Math.max(dynamicCooldown, minCooldown); // Ensure cooldown doesn't go below minimum

          // Continuously shoot if enemies exist and cooldown is over
          if (
            !this.fireLocked &&
            numEnemies > 0 &&
            time > this.lastShotTime + dynamicCooldown
          ) {
            this.playerShoot();
            this.lastShotTime = time;
          }

          // Update bullets
          this.bulletsGroup.children.entries.forEach((bullet) => {
            this.updateBullet(bullet);
          });

          // Update enemies
          this.enemiesGroup.children.entries.forEach((enemy) => {
            // Check collision with wall
            if (
              enemy.active &&
              Phaser.Geom.Intersects.RectangleToRectangle(
                enemy.getBounds(),
                this.wall.getBounds()
              )
            ) {
              // Block enemy at the wall
              enemy.x =
                this.wall.x + this.wall.width / 2 + enemy.displayWidth / 2;
              // Optionally, stop enemy animation or movement here
            } else {
              // Only move if not blocked
              enemy.x -= 0.8;
              if (enemy.x < 0) {
                enemy.destroy();
              }
            }
          });

          // After moving enemies, enforce 30px spacing between them on the same lane
          const sortedEnemies = this.enemiesGroup
            .getChildren()
            .slice()
            .sort((a, b) => a.x - b.x);
          for (let i = 1; i < sortedEnemies.length; i++) {
            const prev = sortedEnemies[i - 1];
            const curr = sortedEnemies[i];
            // Only block if on the same lane (same y)
            if (Math.abs(prev.y - curr.y) < 1) {
              // If the enemy behind is too close, push it back
              if (curr.x - prev.x < 30) {
                curr.x = prev.x + 30;
              }
            }
          }

          // Update collider box positions for all enemies
          this.enemiesGroup.getChildren().forEach((enemy) => {
            if (enemy.hasColliderBox && enemy.colliderBox) {
              enemy.colliderBox.x = enemy.x;
              enemy.colliderBox.y = enemy.y;
            }
          });

          // Check collisions
          this.checkCollisions();

          // Update particle positions to match bullets
          this.bulletsGroup.getChildren().forEach((bullet) => {
            if (bullet.active) {
              // Emit particles at bullet position for trail effect
              this.bulletEmitter.emitParticle(1, bullet.x, bullet.y);
            }
          });

          // Update avatar positions
          this.enemiesGroup.getChildren().forEach((enemy) => {
            if (enemy.update) {
              enemy.update();
            }
          });
        }

        findNearestEnemy(player) {
          let nearestEnemy = null;
          let minDistance = Infinity;

          this.enemiesGroup.children.entries.forEach((enemy) => {
            const distance = Phaser.Math.Distance.Between(
              player.x,
              player.y,
              enemy.x,
              enemy.y
            );
            if (distance < minDistance) {
              minDistance = distance;
              nearestEnemy = enemy;
            }
          });

          return nearestEnemy;
        }

        findFarthestEnemy(player) {
          let farthestEnemy = null;
          let maxDistance = 0;

          this.enemiesGroup.children.entries.forEach((enemy) => {
            const distance = Phaser.Math.Distance.Between(
              player.x,
              player.y,
              enemy.x,
              enemy.y
            );
            if (distance > maxDistance) {
              maxDistance = distance;
              farthestEnemy = enemy;
            }
          });

          return farthestEnemy;
        }

        playerShoot() {
          // Play attack animation when shooting
          this.player.anims.play('guangzu_anim', true);

          // When attack animation completes, return to idle
          this.player.once('animationcomplete-guangzu_anim', () => {
            this.player.anims.play('gz_idle');
          });

          const nearestEnemy = this.findNearestEnemy(this.player);
          const farthestEnemy = this.findFarthestEnemy(this.player);

          if (nearestEnemy) {
            this.createBulletSpread(this.player, nearestEnemy);
            this.createBulletSpread(this.player, nearestEnemy);
          }
          if (farthestEnemy) {
            this.createBulletSpread(this.player, farthestEnemy);
          }
        }

        createBulletSpread(player, target) {
          if (!target || !target.active) {
            return; // Don't shoot if there are no valid enemies
          }

          const startX = player.x + 20;
          const startY = player.y;
          const enemy_vx = -50; // Enemy speed in pixels per second
          const bulletSpeed = 350; // Desired speed of our bullets

          // --- Predictive Aiming Calculation ---
          // 1. Estimate flight time based on current distance and a desired bullet speed.
          const distance = Phaser.Math.Distance.Between(
            startX,
            startY,
            target.x,
            target.y
          );
          let timeToTarget = distance / bulletSpeed;

          // --- High Arc Adjustment for Close Bottom-Lane Enemies ---
          const horizontalDistance = target.x - startX;
          const bottomLaneY = this.laneYPositions[2]; // Get Y of the bottom lane

          // If the enemy is on the bottom lane and close, increase flight time for a higher arc
          if (target.y === bottomLaneY && horizontalDistance < 250) {
            timeToTarget *= 1.5; // This makes the trajectory higher and more curved.
          }

          // 2. Predict the enemy's future position using that flight time.
          const predictedX = target.x + enemy_vx * timeToTarget;
          const predictedY = target.y; // Enemy only moves horizontally.

          // 3. Calculate the required initial velocity to hit the *predicted* position.
          const dx = predictedX - startX;
          const dy = predictedY - startY;

          // This is the core physics calculation for a projectile with gravity.
          const base_vx = dx / timeToTarget;
          const base_vy = dy / timeToTarget - 0.5 * this.gravity * timeToTarget;

          // Convert velocity to angle and power for adjustments
          const baseAngle = Math.atan2(base_vy, base_vx);
          const power = Math.sqrt(base_vx * base_vx + base_vy * base_vy);

          // --- Clamp the angle to allow for steeper shots at close targets ---
          const minAngle = -Phaser.Math.DegToRad(85); // Allow steeper angle for close/low targets
          const maxAngle = -Phaser.Math.DegToRad(30); // -30 degrees
          const clampedAngle = Phaser.Math.Clamp(baseAngle, minAngle, maxAngle);

          // --- Fire 10 bullets in a burst ---
          const numBullets = 4;
          const angleSpacing = Phaser.Math.DegToRad(5); // 5 degrees in radians

          for (let i = 0; i < numBullets; i++) {
            // Calculate the angle for the current bullet in the spread
            const angleOffset = (i - Math.floor(numBullets / 2)) * angleSpacing;
            const currentAngle = clampedAngle + angleOffset;

            // Calculate new velocity components based on the adjusted angle
            const vx = Math.cos(currentAngle) * power;
            const vy = Math.sin(currentAngle) * power;

            // Create bullet
            const bullet = this.add.circle(startX, startY, 10, 0x79a7e4);
            this.physics.world.enable(bullet);

            // Set bullet properties based on calculated trajectory
            bullet.velocityX = vx;
            bullet.velocityY = vy;
            bullet.gravity = this.gravity;

            this.bulletsGroup.add(bullet);

            // Emit just 2 particles when the bullet is created
            this.bulletEmitter.emitParticle(2, startX, startY);
          }

          // Calculate which lane the target is in
          let laneIndex = 1; // default middle
          for (let i = 0; i < this.laneYPositions.length; i++) {
            if (target.y === this.laneYPositions[i]) {
              laneIndex = i;
              break;
            }
          }

          // Set bullet velocity based on lane
          let velocityX = 600; // default
          let velocityY = 0; // default

          if (laneIndex === 2) {
            // bottom lane
            velocityX = 800; // increase horizontal speed for bottom lane
            velocityY = 80; // add a bit more downward arc if needed
          }

          // Create bullet
          const bullet = this.physics.add.sprite(
            player.x + 40,
            player.y,
            'bullet'
          );
          bullet.setScale(0.5);

          // Set velocity for parabolic arc
          bullet.body.velocity.x = velocityX;
          bullet.body.velocity.y = velocityY;

          // Optional: adjust gravity for more arc
          bullet.body.setGravityY(this.gravity);

          this.bulletsGroup.add(bullet);
        }

        updateBullet(bullet) {
          // Apply gravity and movement
          bullet.velocityY += bullet.gravity * 0.016; // Gravity effect
          bullet.y += bullet.velocityY * 0.016;
          bullet.x += bullet.velocityX * 0.016; // Horizontal movement

          // Rotation is not needed for a circular bullet
          // bullet.rotation = Math.atan2(bullet.velocityY, bullet.velocityX);

          const bottomLaneY = this.laneYPositions[2];

          // Remove bullet if it goes off screen or below the bottom lane
          if (
            bullet.y > bottomLaneY ||
            bullet.x > this.sys.game.config.width ||
            bullet.x < 0
          ) {
            const explosion = this.add.sprite(
              bullet.x,
              bullet.y,
              'explosion_1'
            );
            explosion.setScale(0.2); // Adjust scale as needed
            explosion.on('animationcomplete', () => {
              explosion.destroy();
            });
            explosion.play('explosion');
            bullet.destroy();
          }
        }

        spawnEnemy(
          x,
          y,
          username = '',
          userAvatar = '',
          userId = '',
          isBoss = false
        ) {
          console.log(
            `Spawning enemy at (${x}, ${y}) for ${username} with avatar ${userAvatar}`
          );

          if (x < 100) {
            x = 100;
          }
          // Create enemy as a sprite and play walk animation
          let enemy;
          if (isBoss) {
            enemy = this.add.sprite(x, y, 'boss_walk_000000');
            enemy.anims.play('boss_walk');
            enemy.setScale(1.5); // Boss is bigger
            enemy.hp = this.enemyHP * 10; // Boss has more HP
          } else {
            enemy = this.add.sprite(x, y, 'zombie_walk_000');
            enemy.anims.play('zombie_walk');
            enemy.setScale(0.9);
            enemy.hp = this.enemyHP;
            enemy.setFlipX(true);
          }

          this.physics.world.enable(enemy);

          // Resize: set height to 90px (3x bigger), maintain aspect ratio
          // const scale = 90 / enemy.height;
          // enemy.setScale(scale);

          // Align bottom edge to lane line
          enemy.y = y - enemy.displayHeight / 2;

          // Give the enemy 20 HP
          // enemy.hp = this.enemyHP;

          this.enemiesGroup.add(enemy);

          // --- Draw red box collider for enemy ---
          const box = this.add.graphics();
          box.lineStyle(2, 0xff0000, 1);

          if (isBoss) {
            const leftPadding = -30;
            const bottomPadding = -30;
            // Draw debug box with 30px left and bottom padding
            box.strokeRect(
              -enemy.displayWidth / 2 - leftPadding, // 30px left
              -enemy.displayHeight / 2,
              enemy.displayWidth + leftPadding, // wider
              enemy.displayHeight + bottomPadding // taller (bottom)
            );
            // Adjust physics body size and offset to match the box
            enemy.body.setSize(
              enemy.displayWidth + leftPadding, // wider
              enemy.displayHeight + bottomPadding // taller
            );
            enemy.body.setOffset(
              -enemy.displayWidth / 2 - leftPadding, // match left
              -enemy.displayHeight / 2 // match top
            );
          } else {
            box.strokeRect(
              -enemy.displayWidth / 2,
              -enemy.displayHeight / 2,
              enemy.displayWidth,
              enemy.displayHeight
            );
            enemy.body.setSize(enemy.displayWidth, enemy.displayHeight);
            enemy.body.setOffset(
              -enemy.displayWidth / 2,
              -enemy.displayHeight / 2
            );
          }
          box.setDepth(10);

          // Make the box follow the enemy
          box.x = enemy.x;
          box.y = enemy.y;
          enemy.colliderBox = box;
          enemy.hasColliderBox = true;
          box.setVisible(true); // Hide the collider box by default

          // Create a container to hold the avatar and its mask
          const avatarContainer = this.add.container(
            enemy.x,
            enemy.y - enemy.displayHeight / 2 - 200
          );

          // Add username text above the avatar
          if (username) {
            const usernameText = this.add.text(0, -40, username, {
              font: '20px Arial',
              color: '#ffffff',
              align: 'center',
              stroke: '#000',
              strokeThickness: 4,
            });
            usernameText.setOrigin(0.5, 0.5);
            avatarContainer.add(usernameText);
          }
          // Determine the avatar key
          let avatarKey = 'avatarGojo';
          if (
            userAvatar &&
            typeof userAvatar === 'string' &&
            userAvatar.startsWith('http')
          ) {
            avatarKey = `avatar_${username || Date.now()}`;
          }

          // Helper to add the avatar image to the container
          const addAvatarImage = (key) => {
            const avatarSize = 50;

            // Draw silver border (rectangle)
            const border = this.add.graphics();
            border.lineStyle(4, 0xc0c0c0, 1); // Silver color, 4px width
            border.strokeRect(
              -avatarSize / 2,
              -avatarSize / 2,
              avatarSize,
              avatarSize
            );

            // Add border to container first (so it's behind the avatar)
            avatarContainer.add(border);

            // Add avatar image
            const avatar = this.add.image(0, 0, key);
            const avatarScale =
              avatarSize / Math.max(avatar.width, avatar.height);
            avatar.setScale(avatarScale);
            avatarContainer.add(avatar);
          };

          // If it's a URL and not loaded, load it dynamically
          if (avatarKey !== 'avatarGojo' && !this.textures.exists(avatarKey)) {
            this.load.image(avatarKey, userAvatar);
            this.load.once('complete', () => {
              addAvatarImage(avatarKey);
            });
            this.load.start();
          } else {
            addAvatarImage(avatarKey);
          }

          // Store reference on the enemy
          enemy.avatarContainer = avatarContainer;

          // Update function to follow enemy
          enemy.update = function () {
            if (this.active && this.avatarContainer) {
              this.avatarContainer.x = this.x;
              this.avatarContainer.y = this.y - this.displayHeight / 2 + 10;
            }
          };

          // Clean up on destroy
          const originalDestroy = enemy.destroy;
          enemy.destroy = function () {
            if (this.avatarContainer) {
              this.avatarContainer.destroy();
            }
            originalDestroy.apply(this);
          };

          // --- Add HP bar as individual units ---
          const barWidth = 40;
          const barHeight = 10;
          const barOffsetY = enemy.displayHeight / 2 - 35;
          const hpUnits = enemy.hp;
          const unitSpacing = barWidth / hpUnits;

          enemy.hpBarDots = [];
          const hpBarContainer = this.add.container(
            enemy.x,
            enemy.y - barOffsetY
          );
          hpBarContainer.setDepth(20);

          for (let i = 0; i < hpUnits; i++) {
            // Start with all dots green
            const dot = this.add.circle(
              -barWidth / 2 + i * unitSpacing + unitSpacing / 2,
              0,
              barHeight / 2,
              0x00ff00
            );
            hpBarContainer.add(dot);
            enemy.hpBarDots.push(dot);
          }

          enemy.hpBarContainer = hpBarContainer;
          enemy.maxHp = enemy.hp;

          // Update function to move HP bar with enemy
          const oldUpdate = enemy.update;
          enemy.update = function () {
            if (oldUpdate) oldUpdate.call(this);
            if (this.hpBarContainer) {
              this.hpBarContainer.x = this.x;
              this.hpBarContainer.y = this.y - barOffsetY;
            }
          };

          // Destroy HP bar when enemy is destroyed
          const oldDestroy = enemy.destroy;
          enemy.destroy = function () {
            if (this.hpBarContainer) {
              this.hpBarContainer.destroy();
            }
            if (oldDestroy) oldDestroy.call(this);
          };
        }

        checkCollisions() {
          this.bulletsGroup.children.entries.forEach((bullet) => {
            this.enemiesGroup.children.entries.forEach((enemy) => {
              if (enemy.active && bullet.active) {
                // Define center area (e.g., 40% of enemy width/height)
                const centerWidth = enemy.displayWidth * 0.4;
                const centerHeight = enemy.displayHeight * 0.4;
                const centerX = enemy.x - centerWidth / 2;
                const centerY = enemy.y - centerHeight / 2;
                const centerRect = new Phaser.Geom.Rectangle(
                  centerX,
                  centerY,
                  centerWidth,
                  centerHeight
                );

                // Check if bullet overlaps the center area
                if (
                  Phaser.Geom.Rectangle.Overlaps(bullet.getBounds(), centerRect)
                ) {
                  const explosion = this.add.sprite(
                    bullet.x,
                    bullet.y,
                    'explosion_1'
                  );
                  explosion.setScale(0.2); // Adjust scale as needed
                  explosion.on('animationcomplete', () => {
                    explosion.destroy();
                  });
                  explosion.play('explosion');
                  this.sound.play('explosionSound', { volume: 0.5 });
                  // Bullet hit the center of the enemy!
                  bullet.destroy();
                  enemy.hp -= 1;
                  // Update HP bar dots: green for remaining HP, red for lost HP
                  if (enemy.hpBarDots) {
                    for (let i = 0; i < enemy.maxHp; i++) {
                      if (i < enemy.hp) {
                        enemy.hpBarDots[i].setFillStyle(0x00ff00); // Green for remaining HP
                      } else {
                        enemy.hpBarDots[i].setFillStyle(0xff0000); // Red for lost HP
                      }
                    }
                  }
                  if (enemy.hp <= 0) {
                    if (enemy.colliderBox) {
                      enemy.colliderBox.destroy();
                      enemy.colliderBox = null;
                    }
                    enemy.destroy();
                    console.log('Enemy defeated!');
                  } else {
                    if (enemy.hp === 2) {
                      enemy.setTint(0xffa500);
                    } else if (enemy.hp === 1) {
                      enemy.setTint(0xffff00);
                    }
                  }
                }
              }
            });
          });

          // Check if enemy reaches player
          this.enemiesGroup.children.entries.forEach((enemy) => {
            if (enemy.active && this.player.active) {
              // Get center points
              const enemyCenter = { x: enemy.x, y: enemy.y };
              const playerCenter = { x: this.player.x, y: this.player.y };

              // Define a small radius for "center" collision (adjust as needed)
              const centerRadius = 20;

              // Check if enemy center is within centerRadius of player center
              const dist = Phaser.Math.Distance.Between(
                enemyCenter.x,
                enemyCenter.y,
                playerCenter.x,
                playerCenter.y
              );

              if (dist < centerRadius) {
                // Destroy the collider box if it exists
                if (enemy.colliderBox) {
                  enemy.colliderBox.destroy();
                  enemy.colliderBox = null;
                }
                enemy.destroy();
                console.log('Player hit at center! Game Over!');
                // Add game over logic here
              }
            }
          });

          // Collect enemies to remove after iteration
          const enemiesToRemove = [];

          this.enemiesGroup.getChildren().forEach((enemy) => {
            if (enemy.hp <= 0) {
              // Destroy the collider box if it exists
              if (enemy.colliderBox) {
                enemy.colliderBox.destroy();
                enemy.colliderBox = null;
              }
              enemiesToRemove.push(enemy);
            }
          });

          // Remove and destroy enemies after iteration
          enemiesToRemove.forEach((enemy) => {
            this.enemiesGroup.remove(enemy, true, true);
          });
        }
      }

      // Game configuration
      const config = {
        type: Phaser.AUTO,
        width: 1000,
        height: 800,
        physics: {
          default: 'arcade',
          arcade: {
            gravity: { y: 0 },
            debug: false,
          },
        },
        scene: BulletGame,
        audio: {
          disableWebAudio: false,
        },
        // Add these two lines:
        autoPause: false,
        autoFocus: true,
      };

      // Start the game
      const game = new Phaser.Game(config);
      game.events.off('blur', game.scene.pause);
      game.events.off('focus', game.scene.resume);
      game.events.on('hidden', () => {
        game.sound.context.resume();
        game.scene.resume();
      });
      game.events.on('visible', () => {
        game.sound.context.resume();
        game.scene.resume();
      });
      window.addEventListener('blur', () => {
        game.sound.context.resume();
      });
      window.addEventListener('focus', () => {
        game.sound.context.resume();
      });
      const { ipcRenderer } = window.require('electron');
      try {
        // TikTok chat integration
        ipcRenderer.on('tiktok-chat', (event, data) => {
          console.log('screen2', data);
        });

        ipcRenderer.on('tiktok-like', (event, data) => {
          console.log('tiktok-like', data);
          emitter.emit(
            'spawn-enemy',
            data.name,
            data.photo,
            data.user,
            data.likeCount
          );
        });
      } catch (e) {
        console.log(e);

        // Not running in Electron, ignore
      }
    </script>
  </body>
</html>
