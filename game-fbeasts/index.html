<!DOCTYPE html>
<html>
  <head>
    <title>Phaser - 4 Lane Defense Game (Fixed)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #1a1a1a;
      }
      canvas {
        border: 2px solid #555;
      }
    </style>
  </head>
  <body>
    <script>
      const HP_BAR_WIDTH = 30;
      const HP_BAR_HEIGHT = 5;
      const MAX_ENEMY_HP = 3;

      class GameScene extends Phaser.Scene {
        constructor() {
          super('GameScene');
          this.player = null;
          this.enemies = null;
          this.score = 0;
          this.scoreText = null;
          this.gameOver = false;

          this.lanePositions = [];
          this.playerLaneIndex = 1;
        }

        preload() {
          // No assets to load
        }

        create() {
          this.gameOver = false;
          this.score = 0;

          this.lanePositions = [150, 250, 350, 450];
          this.playerLaneIndex = 1;

          // --- Create Graphics for Sprites ---
          const playerGraphics = this.make.graphics({
            fillStyle: { color: 0xffffff },
            lineStyle: { width: 2, color: 0x0000ff },
          });
          playerGraphics.fillCircle(10, 10, 10);
          playerGraphics.generateTexture('player', 20, 20);
          playerGraphics.destroy();

          const enemyGraphics = this.make.graphics({
            fillStyle: { color: 0xff0000 },
          });
          enemyGraphics.fillCircle(8, 8, 8);
          enemyGraphics.generateTexture('enemy', 16, 16);
          enemyGraphics.destroy();

          const homingProjectileGraphics = this.make.graphics({
            fillStyle: { color: 0x00ffff },
          });
          homingProjectileGraphics.fillRect(0, 3, 12, 2);
          homingProjectileGraphics.beginPath();
          homingProjectileGraphics.moveTo(12, 0);
          homingProjectileGraphics.lineTo(16, 4);
          homingProjectileGraphics.lineTo(12, 8);
          homingProjectileGraphics.closePath();
          homingProjectileGraphics.fillPath();
          homingProjectileGraphics.generateTexture('homing_bolt', 16, 8);
          homingProjectileGraphics.destroy();

          const fireParticleGraphics = this.make.graphics({
            fillStyle: { color: 0xffa500 },
          });
          fireParticleGraphics.fillCircle(3, 3, 3);
          fireParticleGraphics.generateTexture('fire_particle', 6, 6);
          fireParticleGraphics.destroy();

          const lotusGraphics = this.make.graphics({
            fillStyle: { color: 0xff69b4 },
          });
          lotusGraphics.slice(
            8,
            8,
            8,
            Phaser.Math.DegToRad(270),
            Phaser.Math.DegToRad(90),
            true
          );
          lotusGraphics.fillPath();
          lotusGraphics.generateTexture('lotus', 16, 16);
          lotusGraphics.destroy();

          // --- Setup Game World ---
          this.cameras.main.setBackgroundColor('#006400');

          this.player = this.physics.add
            .sprite(50, this.lanePositions[this.playerLaneIndex], 'player')
            .setImmovable(true);
          this.player.body.setCircle(10);
          this.player.body.setAllowGravity(false);

          this.input.keyboard.on('keydown-W', () => {
            if (!this.gameOver && this.playerLaneIndex > 0) {
              this.playerLaneIndex--;
            }
          });
          this.input.keyboard.on('keydown-S', () => {
            if (
              !this.gameOver &&
              this.playerLaneIndex < this.lanePositions.length - 1
            ) {
              this.playerLaneIndex++;
            }
          });

          // Keyboard input for skills
          this.input.keyboard.on('keydown-ONE', () => this.fireBreath());
          this.input.keyboard.on('keydown-TWO', () => this.fireHomingBolt());
          this.input.keyboard.on('keydown-THREE', () => this.fireLotusNova());

          // Skill lock states
          this.homingBoltUnlocked = false;
          this.lotusNovaUnlocked = false;

          // Keyboard input for unlocking skills
          this.input.keyboard.on('keydown-TWO', () => {
            this.homingBoltUnlocked = true;
            this.showDamageText(
              this.player.x,
              this.player.y - 30,
              'Homing Bolt Unlocked!'
            );
          });
          this.input.keyboard.on('keydown-THREE', () => {
            this.lotusNovaUnlocked = true;
            this.showDamageText(
              this.player.x,
              this.player.y - 30,
              'Lotus Nova Unlocked!'
            );
          });

          this.enemies = this.add.group();

          this.homingBolts = this.physics.add.group({
            defaultKey: 'homing_bolt',
            maxSize: 100,
          });
          this.fireParticles = this.physics.add.group({
            defaultKey: 'fire_particle',
            maxSize: 300,
          });
          this.lotusFlowers = this.physics.add.group({
            defaultKey: 'lotus',
            maxSize: 200,
          });

          // Add gravity for more realistic projectile physics
          this.physics.world.gravity.y = 300;

          // --- Setup Collisions ---
          this.physics.add.overlap(
            this.homingBolts,
            this.enemies,
            this.handleProjectileHit,
            null,
            this
          );
          this.physics.add.overlap(
            this.fireParticles,
            this.enemies,
            this.handleProjectileHit,
            null,
            this
          );
          this.physics.add.overlap(
            this.lotusFlowers,
            this.enemies,
            this.handleProjectileHit,
            null,
            this
          );
          this.physics.add.overlap(
            this.player,
            this.enemies,
            this.handlePlayerHit,
            null,
            this
          );

          // --- Timers ---
          this.time.addEvent({
            delay: 500,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true,
          });
          this.time.addEvent({
            delay: 500,
            callback: this.fireHomingBolt,
            callbackScope: this,
            loop: true,
          });
          this.time.addEvent({
            delay: 500,
            callback: this.fireBreath,
            callbackScope: this,
            loop: true,
          });
          this.time.addEvent({
            delay: 3000,
            callback: this.fireLotusNova,
            callbackScope: this,
            loop: true,
          });

          // --- UI ---
          this.scoreText = this.add.text(16, 16, 'Score: 0', {
            fontSize: '32px',
            fill: '#fff',
            stroke: '#000',
            strokeThickness: 4,
          });
        }

        update() {
          if (this.gameOver) {
            return;
          }

          const targetY = this.lanePositions[this.playerLaneIndex];
          this.player.y = Phaser.Math.Interpolation.Linear(
            [this.player.y, targetY],
            0.2
          );

          // Update enemy paths
          this.enemies.getChildren().forEach((enemyContainer) => {
            if (enemyContainer.active) {
              const progress = enemyContainer.getData('pathProgress') + 0.005;
              enemyContainer.setData('pathProgress', progress);

              // Add slight sine wave movement for more dynamic paths
              const laneIndex = enemyContainer.getData('laneIndex');
              const baseLaneY = this.lanePositions[laneIndex];
              const waveOffset = Math.sin(progress * 8) * 15;

              // Gradually move toward player's lane as they approach
              const playerLaneY = this.lanePositions[this.playerLaneIndex];
              const convergeFactor = Math.max(
                0,
                (800 - enemyContainer.x) / 600
              );
              const targetY =
                baseLaneY +
                waveOffset +
                (playerLaneY - baseLaneY) * convergeFactor * 0.3;

              enemyContainer.y = Phaser.Math.Interpolation.Linear(
                [enemyContainer.y, targetY],
                0.05
              );
            }
          });
        }

        spawnEnemy() {
          if (this.gameOver) return;

          const laneIndex = Phaser.Math.Between(
            0,
            this.lanePositions.length - 1
          );
          const y = this.lanePositions[laneIndex];
          const x = 820;

          const hpBarBg = this.add
            .rectangle(0, -15, HP_BAR_WIDTH, HP_BAR_HEIGHT, 0xff0000)
            .setOrigin(0.5);
          const hpBar = this.add
            .rectangle(0, -15, HP_BAR_WIDTH, HP_BAR_HEIGHT, 0x00ff00)
            .setOrigin(0.5);
          const enemySprite = this.add.sprite(0, 0, 'enemy');
          const enemyContainer = this.add.container(x, y, [
            hpBarBg,
            hpBar,
            enemySprite,
          ]);

          enemyContainer.setSize(16, 16);
          this.physics.world.enable(enemyContainer);

          enemyContainer.setData('health', MAX_ENEMY_HP);
          enemyContainer.setData('hpBar', hpBar);
          enemyContainer.setData('laneIndex', laneIndex);
          enemyContainer.setData('pathProgress', 0);

          enemyContainer.body.setVelocityX(-120);
          enemyContainer.body.setAllowGravity(false);

          this.enemies.add(enemyContainer);
        }

        findNearestEnemy() {
          let nearestEnemy = null;
          let minDistance = Number.MAX_VALUE;

          this.enemies.getChildren().forEach((enemyContainer) => {
            if (enemyContainer.active) {
              const distance = Phaser.Math.Distance.Between(
                this.player.x,
                this.player.y,
                enemyContainer.x,
                enemyContainer.y
              );
              if (distance < minDistance) {
                minDistance = distance;
                nearestEnemy = enemyContainer;
              }
            }
          });
          return nearestEnemy;
        }

        handleProjectileHit(projectile, enemyContainer) {
          // Check if the container is still active (not already destroyed)
          if (!enemyContainer.active) {
            return;
          }

          projectile.destroy();

          const health = enemyContainer.getData('health') - 1;
          enemyContainer.setData('health', health);
          this.showDamageText(enemyContainer.x, enemyContainer.y, 666);

          // Check if enemy is still alive before updating HP bar
          if (health > 0) {
            const hpBar = enemyContainer.getData('hpBar');
            // Additional safety check to ensure hpBar still exists
            if (hpBar && hpBar.active) {
              hpBar.width = (health / MAX_ENEMY_HP) * HP_BAR_WIDTH;
            }
          } else {
            // Enemy is dead - destroy it
            this.enemies.remove(enemyContainer, true); // Remove from group and destroy
            enemyContainer.destroy(); // Ensure all parts are gone
            this.score += 10;
            this.scoreText.setText('Score: ' + this.score);
          }
        }

        handlePlayerHit(player, enemyContainer) {
          if (this.gameOver) return;

          this.gameOver = true;
          this.physics.pause();
          this.enemies.getChildren().forEach((c) => {
            if (c.body) c.body.stop();
          });
          player.setTint(0xff0000);

          this.add
            .text(400, 250, 'GAME OVER', {
              fontSize: '64px',
              fill: '#ff0000',
              stroke: '#fff',
              strokeThickness: 6,
            })
            .setOrigin(0.5);
          this.add
            .text(400, 350, 'Click to Restart', {
              fontSize: '32px',
              fill: '#fff',
              stroke: '#000',
              strokeThickness: 4,
            })
            .setOrigin(0.5);

          this.input.once('pointerdown', () => this.scene.restart());
        }

        fireHomingBolt() {
          if (!this.homingBoltUnlocked || this.gameOver) return;
          const e = this.findNearestEnemy();
          if (e) {
            const b = this.homingBolts.get(this.player.x + 15, this.player.y);
            if (b) {
              b.setActive(true).setVisible(true);
              b.body.setAllowGravity(true);

              // Calculate parabolic trajectory to intercept enemy path
              const distance = Phaser.Math.Distance.Between(
                this.player.x,
                this.player.y,
                e.x,
                e.y
              );
              const timeToTarget = distance / 400; // Base speed for calculation

              // Predict where enemy will be
              const futureX = e.x - e.body.velocity.x * timeToTarget;
              const futureY = e.y;

              // Calculate high arc trajectory
              const dx = futureX - this.player.x;
              const dy = futureY - this.player.y;
              const angle = Math.atan2(dy, dx);
              const launchAngle = angle - 0.4; // High arc

              const velocity =
                Math.sqrt(dx * dx + (dy + 200) * (dy + 200)) / timeToTarget;
              const clampedVelocity = Math.min(Math.max(velocity, 500), 900);

              b.setRotation(launchAngle);
              this.physics.velocityFromRotation(
                launchAngle,
                clampedVelocity,
                b.body.velocity
              );
              this.time.delayedCall(3000, () => {
                if (b.active) b.destroy();
              });
            }
          }
        }
        fireBreath() {
          if (this.gameOver) return;
          // Fixed 45-degree upward angle (up-right)
          const angle = Phaser.Math.DegToRad(-15);
          for (let i = 0; i < 5; i++) {
            const p = this.fireParticles.get(
              this.player.x + 10,
              this.player.y + Phaser.Math.Between(-8, 8)
            );
            if (p) {
              p.setActive(true).setVisible(true);
              p.body.setAllowGravity(true);

              // Spread pattern around -45 degrees
              const spread = (i - 2) * 0.12; // small spread
              const launchAngle = angle + spread;

              const velocity = Phaser.Math.Between(450, 650);
              this.physics.velocityFromRotation(
                launchAngle,
                velocity,
                p.body.velocity
              );
              this.time.delayedCall(1500, () => {
                if (p.active) p.destroy();
              });
            }
          }
        }
        fireLotusNova() {
          if (!this.lotusNovaUnlocked || this.gameOver) return;
          const n = 24;
          for (let i = 0; i < n; i++) {
            const f = this.lotusFlowers.get(this.player.x, this.player.y);
            if (f) {
              f.setActive(true).setVisible(true);
              f.body.setAllowGravity(true);

              const a = (i / n) * 2 * Math.PI;
              const velocity = Phaser.Math.Between(400, 600);
              // Create high arcing shots
              const arcAngle = a - 0.5; // Strong upward arc
              f.setRotation(a + Math.PI / 2);
              this.physics.velocityFromRotation(
                arcAngle,
                velocity,
                f.body.velocity
              );
              this.time.delayedCall(2800, () => {
                if (f.active) f.destroy();
              });
            }
          }
        }
        showDamageText(x, y, d) {
          const t = this.add
            .text(x, y, `-${d}`, {
              fontSize: '16px',
              fill: '#ffdd00',
              stroke: '#000',
              strokeThickness: 2,
            })
            .setOrigin(0.5);
          this.tweens.add({
            targets: t,
            y: y - 50,
            alpha: 0,
            duration: 800,
            ease: 'Cubic.easeOut',
            onComplete: () => t.destroy(),
          });
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: 'arcade',
          arcade: {
            // debug: true
          },
        },
        scene: [GameScene],
      };

      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
