<!DOCTYPE html>
<html>
  <head>
    <title>Phaser - Lane Defense Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #1a1a1a;
      }
      canvas {
        border: 2px solid #555;
      }
    </style>
  </head>
  <body>
    <script>
      class GameScene extends Phaser.Scene {
        constructor() {
          super('GameScene');
          this.player = null;
          this.cursors = null;
          this.enemies = null;
          this.score = 0;
          this.scoreText = null;
          this.gameOver = false;
        }

        // No external assets needed, we'll generate graphics on the fly
        preload() {
          // This game uses procedurally generated graphics, so no assets are loaded.
        }

        create() {
          this.gameOver = false;
          this.score = 0;

          // --- Create Graphics for Sprites (so we don't need external files) ---
          // Player (a white circle with a blue outline)
          const playerGraphics = this.make.graphics({
            fillStyle: { color: 0xffffff },
            lineStyle: { width: 2, color: 0x0000ff },
          });
          playerGraphics.fillCircle(10, 10, 10);
          playerGraphics.strokeCircle(10, 10, 10);
          playerGraphics.generateTexture('player', 20, 20);
          playerGraphics.destroy();

          // Enemy (a red circle)
          const enemyGraphics = this.make.graphics({
            fillStyle: { color: 0xff0000 },
          });
          enemyGraphics.fillCircle(8, 8, 8);
          enemyGraphics.generateTexture('enemy', 16, 16);
          enemyGraphics.destroy();

          // Projectile 1 (Homing Purple Orb)
          const homingProjectileGraphics = this.make.graphics({
            fillStyle: { color: 0xcc00ff },
          });
          homingProjectileGraphics.fillCircle(4, 4, 4);
          homingProjectileGraphics.generateTexture('homing_bolt', 8, 8);
          homingProjectileGraphics.destroy();

          // Projectile 2 (Fire Particle)
          const fireParticleGraphics = this.make.graphics({
            fillStyle: { color: 0xffa500 },
          });
          fireParticleGraphics.fillCircle(3, 3, 3);
          fireParticleGraphics.generateTexture('fire_particle', 6, 6);
          fireParticleGraphics.destroy();

          // Projectile 3 (Lotus Flower)
          const lotusGraphics = this.make.graphics({
            fillStyle: { color: 0xff69b4 },
          });
          lotusGraphics.slice(
            8,
            8,
            8,
            Phaser.Math.DegToRad(270),
            Phaser.Math.DegToRad(90),
            true
          );
          lotusGraphics.fillPath();
          lotusGraphics.generateTexture('lotus', 16, 16);
          lotusGraphics.destroy();

          // --- Setup Game World ---
          this.cameras.main.setBackgroundColor('#006400');

          // Player setup - **CHANGED**
          // Start player on the left side of the screen
          this.player = this.physics.add
            .sprite(100, 300, 'player')
            .setCollideWorldBounds(true)
            .setImmovable(true); // Player cannot be pushed by enemies
          this.player.body.setCircle(10);

          // Input setup
          this.cursors = this.input.keyboard.addKeys('W,S'); // Only need W and S for vertical movement

          // Groups for physics objects
          this.enemies = this.physics.add.group({
            key: 'enemy',
            runChildUpdate: true,
          });

          this.homingBolts = this.physics.add.group({
            defaultKey: 'homing_bolt',
            maxSize: 100,
          });
          this.fireParticles = this.physics.add.group({
            defaultKey: 'fire_particle',
            maxSize: 300,
          });
          this.lotusFlowers = this.physics.add.group({
            defaultKey: 'lotus',
            maxSize: 200,
          });

          // --- Setup Collisions ---
          this.physics.add.overlap(
            this.homingBolts,
            this.enemies,
            this.handleProjectileHit,
            null,
            this
          );
          this.physics.add.overlap(
            this.fireParticles,
            this.enemies,
            this.handleProjectileHit,
            null,
            this
          );
          this.physics.add.overlap(
            this.lotusFlowers,
            this.enemies,
            this.handleProjectileHit,
            null,
            this
          );
          this.physics.add.overlap(
            this.player,
            this.enemies,
            this.handlePlayerHit,
            null,
            this
          );

          // --- Timers for Spawning and Attacks ---
          // Spawn an enemy every 500ms
          this.time.addEvent({
            delay: 500,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true,
          });

          // Attack 1: Homing Bolts (fires every 250ms)
          this.time.addEvent({
            delay: 250,
            callback: this.fireHomingBolt,
            callbackScope: this,
            loop: true,
          });

          // Attack 2: Fire Breath (fires every 50ms)
          this.time.addEvent({
            delay: 50,
            callback: this.fireBreath,
            callbackScope: this,
            loop: true,
          });

          // Attack 3: Lotus Nova (fires every 4 seconds)
          this.time.addEvent({
            delay: 4000,
            callback: this.fireLotusNova,
            callbackScope: this,
            loop: true,
          });

          // --- UI ---
          this.scoreText = this.add.text(16, 16, 'Score: 0', {
            fontSize: '32px',
            fill: '#fff',
            stroke: '#000',
            strokeThickness: 4,
          });
        }

        update() {
          if (this.gameOver) {
            return;
          }

          // --- Player Movement - **CHANGED** ---
          // Player can now only move up and down
          this.player.setVelocity(0);
          const speed = 200;

          if (this.cursors.W.isDown) {
            this.player.setVelocityY(-speed);
          } else if (this.cursors.S.isDown) {
            this.player.setVelocityY(speed);
          }

          // --- Make Enemies Face Player ---
          this.enemies.getChildren().forEach((enemy) => {
            // No need to set rotation in this game style, but moving towards player is key
            this.physics.moveToObject(enemy, this.player, 80); // 80 is enemy speed
          });
        }

        // --- Helper Functions ---

        spawnEnemy() {
          // **FUNCTION REWRITTEN**
          if (this.gameOver) return;

          // Spawn enemies only from the right edge
          const x = 820; // Just off the right side of the screen (width is 800)
          const y = Phaser.Math.Between(50, 550); // Random Y position within a reasonable range

          const enemy = this.enemies.create(x, y, 'enemy');
          enemy.body.setCircle(8);
          enemy.setData('health', 3); // Enemy has 3 HP
        }

        findNearestEnemy() {
          let nearestEnemy = null;
          let minDistance = Number.MAX_VALUE;

          this.enemies.getChildren().forEach((enemy) => {
            const distance = Phaser.Math.Distance.Between(
              this.player.x,
              this.player.y,
              enemy.x,
              enemy.y
            );
            if (distance < minDistance) {
              minDistance = distance;
              nearestEnemy = enemy;
            }
          });
          return nearestEnemy;
        }

        fireHomingBolt() {
          if (this.gameOver) return;

          const enemy = this.findNearestEnemy();
          if (enemy) {
            const bolt = this.homingBolts.get(this.player.x, this.player.y);
            if (bolt) {
              bolt.setActive(true).setVisible(true);
              this.physics.moveToObject(bolt, enemy, 400); // 400 is projectile speed
            }
          }
        }

        fireBreath() {
          if (this.gameOver) return;

          const enemy = this.findNearestEnemy();
          if (enemy) {
            for (let i = 0; i < 3; i++) {
              // Fire 3 particles at once for a spread effect
              const particle = this.fireParticles.get(
                this.player.x,
                this.player.y
              );
              if (particle) {
                particle.setActive(true).setVisible(true);
                const angle = Phaser.Math.Angle.Between(
                  this.player.x,
                  this.player.y,
                  enemy.x,
                  enemy.y
                );
                const randomAngle = angle + Phaser.Math.FloatBetween(-0.3, 0.3); // Add randomness
                this.physics.velocityFromRotation(
                  randomAngle,
                  350,
                  particle.body.velocity
                );
                this.time.delayedCall(500, () => particle.destroy());
              }
            }
          }
        }

        fireLotusNova() {
          if (this.gameOver) return;

          const numFlowers = 36;
          for (let i = 0; i < numFlowers; i++) {
            const flower = this.lotusFlowers.get(this.player.x, this.player.y);
            if (flower) {
              flower.setActive(true).setVisible(true);
              const angle = (i / numFlowers) * 2 * Math.PI;
              flower.setRotation(angle + Math.PI / 2);
              this.physics.velocityFromRotation(
                angle,
                250,
                flower.body.velocity
              );
              this.time.delayedCall(1500, () => flower.destroy());
            }
          }
        }

        showDamageText(x, y, damage) {
          const damageText = this.add
            .text(x, y, `-${damage}`, {
              fontSize: '16px',
              fill: '#ffdd00',
              stroke: '#000',
              strokeThickness: 2,
            })
            .setOrigin(0.5);

          this.tweens.add({
            targets: damageText,
            y: y - 50,
            alpha: 0,
            duration: 800,
            ease: 'Cubic.easeOut',
            onComplete: () => {
              damageText.destroy();
            },
          });
        }

        handleProjectileHit(projectile, enemy) {
          projectile.destroy();

          let health = enemy.getData('health') - 1;
          enemy.setData('health', health);
          this.showDamageText(enemy.x, enemy.y, 666);

          if (health <= 0) {
            enemy.destroy();
            this.score += 10;
            this.scoreText.setText('Score: ' + this.score);
          }
        }

        handlePlayerHit(player, enemy) {
          if (this.gameOver) return;

          this.gameOver = true;
          this.physics.pause();
          player.setTint(0xff0000);

          this.add
            .text(400, 250, 'GAME OVER', {
              fontSize: '64px',
              fill: '#ff0000',
              stroke: '#fff',
              strokeThickness: 6,
            })
            .setOrigin(0.5);

          this.add
            .text(400, 350, 'Click to Restart', {
              fontSize: '32px',
              fill: '#fff',
              stroke: '#000',
              strokeThickness: 4,
            })
            .setOrigin(0.5);

          this.input.once('pointerdown', () => {
            this.scene.restart();
          });
        }
      }

      // Phaser Game Configuration
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'phaser-example',
        physics: {
          default: 'arcade',
          arcade: {
            // debug: true // Uncomment to see physics bodies
          },
        },
        scene: [GameScene],
      };

      // Create the game instance
      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
